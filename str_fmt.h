#pragma once

#include <string>
#include <algorithm>
#include <chrono>

#include "common.h"


namespace SyrenLogger {

	class StringFormat {
		// class used by sinks to format strings before outputting log message 

	private:
		// private structure to handle getting date time data depending on set time zone
		struct DateTime {
		private:
			// std::string date-time data
			std::string s_year;
			std::string s_month;
			std::string s_day;
			std::string s_hour;
			std::string s_minute;
			std::string s_second;

			// set time zone (default is UTC)
			TimeZone time_zone;

		public:
			DateTime() {
				// default constructor
				time_zone = TimeZone::UTC;
				s_year = s_month = s_day = s_hour = s_minute = s_second = "00";
			}

			void set_time_zone(TimeZone new_time_zone) {
				// set time zone using enum DateTime
				time_zone = new_time_zone;
			}

			void now() {
				// based on set time zone, generate date time data 
				switch (time_zone) {
				case TimeZone::UTC:
					generate_unix_time();
					break;
				case TimeZone::COLOMBO:
					generate_location_time("Asia/Colombo");
					break;
				default:
					s_year = s_month = s_day = s_hour = s_minute = s_second = "00";
					break;
				}
			}

			std::string get_year() {
				// returns the year generated by now() in 4 digit string format
				return(s_year);
			}

			std::string get_month() {
				// returns the month generated by now() in 2 digit string format
				return(s_month);
			}

			std::string get_day() {
				// returns the day generated by now() in 2 digit string format
				return(s_day);
			}

			std::string get_hour() {
				// returns the hour generated by now() in 2 digit string format
				return(s_hour);
			}

			std::string get_minute() {
				// returns the minute generated by now() in 2 digit string format
				return(s_minute);
			}

			std::string get_second() {
				// returns the second generated by now() in 2 digit string format
				return(s_second);
			}

		private:
			void generate_unix_time() {
				// get the current time based on the unix approximation of UTC

				// use chrono to get the current unix time
				auto tp = std::chrono::system_clock::now();
				auto dp = floor<std::chrono::days>(tp);
				std::chrono::year_month_day ymd{ dp };
				std::chrono::hh_mm_ss time{ floor<std::chrono::milliseconds>(tp - dp) };

				// seperate out date time components
				set_date_time_strings(ymd, time);
			}

			void generate_location_time(const char* time_zone) {
				const auto tp = std::chrono::system_clock::now();
				auto colombo_time_zone = std::chrono::get_tzdb().locate_zone(time_zone);
				auto local = std::chrono::zoned_time{ colombo_time_zone,tp };
				auto dp = floor<std::chrono::days>(local.get_local_time());
				std::chrono::year_month_day ymd{ dp };
				std::chrono::hh_mm_ss time{ floor<std::chrono::milliseconds>(local.get_local_time() - dp) };

				// seperate out date time components
				set_date_time_strings(ymd, time);

			}

			void set_date_time_strings(std::chrono::year_month_day ymd, std::chrono::hh_mm_ss<std::chrono::milliseconds> time)
			{
				int year = int(ymd.year());
				unsigned month = unsigned(ymd.month());
				unsigned day = unsigned(ymd.day());
				int hour = int(time.hours().count());
				int minute = int(time.minutes().count());
				int second = int(time.seconds().count());

				s_year = std::to_string(year);
				s_month = format_two_digit_number((int)month);
				s_day = format_two_digit_number((int)day);
				s_hour = format_two_digit_number((int)hour);
				s_minute = format_two_digit_number((int)minute);
				s_second = format_two_digit_number((int)second);
			}

			std::string format_two_digit_number(int number) {
				// adds a 0 to the string literal of a number if less than 10
				if (number < 10)
					return("0" + std::to_string(number));
				else
					return(std::to_string(number));
			}
		};

	private:
		std::string output_format; // log message formatting instructions (includes date-time, logger name, log level and message layout information )
		unsigned decimal_places; // number of decimal places to use when displaying floating point numbers if precision is enabled (max 6)
		bool set_precision; // displays floating point numbers to given decimal points of precision if enabled 
		DateTime date_time; // stores, generates and gets date time strings based on set time zone  

	public:

		StringFormat() {
			// default contructor
			output_format = "[YYYY/MM/DD hh:mm:ss] [Name] [Level] : [Message]";
			decimal_places = 2;
			set_precision = true;
		}

		StringFormat(std::string string_format, const unsigned init_decimal_places, bool init_precision) : output_format(string_format),
			set_precision(init_precision) {
			// constructor with initialization list (std::string version)
			if (init_decimal_places > 6 || init_decimal_places < 0)
				decimal_places = 6;
			else
				decimal_places = init_decimal_places;
		}

		StringFormat(const char* string_format, const unsigned init_decimal_places, bool init_precision) : set_precision(init_precision) {
			// constructor with initialization list (const char* version)
			output_format = std::string(string_format);
			if (init_decimal_places > 6 || init_decimal_places < 0)
				decimal_places = 6;
			else
				decimal_places = init_decimal_places;
		}

		void enable_precision() {
			// enable formatting decimal point data
			set_precision = true;
		}

		void disable_precision() {
			// disable formatting decimal point data
			set_precision = false;
		}

		void set_decimal_places(const unsigned new_decimal_places) {
			// set the number of decimal places to which floating point numbers will be displayed at (max 6)
			if (new_decimal_places > 6 || new_decimal_places < 0)
				decimal_places = 6;
			else
				decimal_places = new_decimal_places;
		}

		void set_string_format(std::string new_string_format) {
			// change log message formatting instructions (std::string version)
			output_format = new_string_format;
		}

		void set_string_format(const char* new_string_format) {
			// change log message formatting instructions (const char*)
			output_format = std::string(output_format);
		}

		void set_time_zone(TimeZone new_time_zone) {
			// set the required time zone for logging 
			date_time.set_time_zone(new_time_zone);
		}

		template<typename T, typename... Args>
		std::string format(const char* logger_name, LogLevel level, const char* input_message, T t, Args... args) {
			// takes a string literal, applies C# style positional string formatting to it and then formats its layout as specified by output_format
			// input: name of logging sink, priority level of message, message to be formatted, variables to be included in the message
			// output: formatted string

			std::string temp_message(input_message);
			std::string formatted_message = format_(temp_message, 0, t, args...);
			std::string output_message = adjust_string(formatted_message, level, logger_name);

			return (output_message);
		}

		std::string format(const char* logger_name, LogLevel level, const char* input_message) {
			// takes a string literal and formats its layout as specified by output_format
			// input: name of logging sink, priority level of message, message to be formatted
			// output: formatted string

			std::string temp_message(input_message);
			std::string output_message = adjust_string(temp_message, level, logger_name);

			return (output_message);
		}

	private:
		StringFormat(const StringFormat& copy) { decimal_places = 2; set_precision = true; }
		StringFormat& operator=(StringFormat other) {}

		template<typename T, typename... Args>
		std::string format_(std::string input_message, int iteration, T value, Args... args) {
			// C# style positional string formatting for primitive c++ types (multiple arguments)

			// create substring to earch by and string to replace with
			std::string s_value = string_convert(value);
			std::string sub_string = std::string("{") + std::to_string(iteration) + std::string("}");

			// replace based on substring
			std::string::size_type n = 0;
			while ((n = input_message.find(sub_string, n)) != std::string::npos) {
				input_message.replace(n, sub_string.size(), s_value);
				n += s_value.size();
			}


			std::string output_message = format_(input_message, iteration + 1, args...);
			return (output_message);
		}

		template<typename T>
		std::string format_(std::string input_message, int iteration, T value) {
			// C# style positional string formatting for primitive c++ types

			// create substring to search by and string to replace with
			std::string s_value = string_convert(value);
			std::string sub_string = std::string("{") + std::to_string(iteration) + std::string("}");

			// replace based on substring
			std::string::size_type n = 0;
			while ((n = input_message.find(sub_string, n)) != std::string::npos) {
				input_message.replace(n, sub_string.size(), s_value);
				n += s_value.size();
			}

			return (input_message);
		}

		std::string string_convert(short value) {
			// convert a short to a string
			return (std::to_string(value));
		}

		std::string string_convert(int value) {
			// convert an int to a string
			return (std::to_string(value));
		}

		std::string string_convert(long value) {
			// convert a long to a string
			return (std::to_string(value));
		}

		std::string string_convert(long long value) {
			// convert a long long to a string
			return (std::to_string(value));
		}

		std::string string_convert(unsigned short value) {
			// convert an unsigned short to a string
			return (std::to_string(value));
		}

		std::string string_convert(unsigned value) {
			// convert an unsigned int to a string
			return (std::to_string(value));
		}

		std::string string_convert(unsigned long value) {
			// convert an unsigned long to a string
			return (std::to_string(value));
		}

		std::string string_convert(unsigned long long value) {
			// convert an unsigned long long to a string
			return (std::to_string(value));
		}

		std::string string_convert(float value) {
			// convert a float to a string
			std::string output = std::to_string(value);

			// apply decimal point formatting if enabled
			if (set_precision) {
				int length = 0;
				if (decimal_places != 0) {
					length = (int)output.find('.') + decimal_places + 1;
				}
				else
					length = (int)output.find('.');

				output = output.substr(0, length);
			}

			return (output);
		}

		std::string string_convert(double value) {
			// convert a double to a string
			std::string output = std::to_string(value);

			// apply decimal point formatting if enabled
			if (set_precision) {
				int length = 0;
				if (decimal_places != 0) {
					length = (int)output.find('.') + decimal_places + 1;
				}
				else
					length = (int)output.find('.');

				output = output.substr(0, length);
			}

			return (output);
		}

		std::string string_convert(long double value) {
			// convert a long double to a string
			std::string output = std::to_string(value);

			// apply decimal point formatting if enabled
			if (set_precision) {
				int length = 0;
				if (decimal_places != 0) {
					length = (int)output.find('.') + decimal_places + 1;
				}
				else
					length = (int)output.find('.');

				output = output.substr(0, length);
			}

			return (output);
		}

		std::string string_convert(char value) {
			// convert a char to a string
			return (std::string(1, value));
		}

		std::string string_convert(const char* value) {
			// convert a long double to a string
			return (std::string(value));
		}

		std::string string_convert(std::string value) {
			// return value if already a string
			return (value);
		}

		template <typename T>
		std::string string_convert(T value) {
			// creates a compile time error if any non c++ primitive type is passed as an argument to format
			static_assert(typeid(value) == T, "Error: positional formating failed - formatting is defined only for std::strings and c++ primitive types (int, float, ... etc.)");
			return(std::string("NULL"));

		}

		std::string adjust_string(std::string input_message, LogLevel out_level, const char* logger_name) {
			// format string accordinf to the layout specified by output_format

			// handle getting date time components to display in message 
			date_time.now();

			// get replacement strings for log level, logger name and the log message format ready
			std::string log_level = get_log_level_as_string(out_level);
			std::string log_name = std::string(logger_name);
			std::string formatted_message = output_format;

			// replace required date-time, peiority level, logger name and message placeholders with correct data to display 
			if (formatted_message.find("YYYY", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("YYYY", 0), std::string("YYYY").size(), date_time.get_year());

			if (formatted_message.find("MM", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("MM", 0), std::string("MM").size(), date_time.get_month());

			if (formatted_message.find("DD", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("DD", 0), std::string("DD").size(), date_time.get_day());

			if (formatted_message.find("hh", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("hh", 0), std::string("hh").size(), date_time.get_hour());

			if (formatted_message.find("mm", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("mm", 0), std::string("mm").size(), date_time.get_minute());

			if (formatted_message.find("ss", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("ss", 0), std::string("ss").size(), date_time.get_second());

			if (formatted_message.find("Name", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("Name", 0), std::string("Name").size(), log_name);

			if (formatted_message.find("Level", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("Level", 0), std::string("Level").size(), log_level);

			if (formatted_message.find("[Message]", 0) != std::string::npos)
				formatted_message.replace(formatted_message.find("[Message]", 0), std::string("[Message]").size(), input_message);

			return (formatted_message);
		}

		std::string get_log_level_as_string(LogLevel level) {
			// convert logger priority level into a string
			switch (level) {
			case LogLevel::LTRACE:
				return(std::string("TRACE"));
				break;
			case LogLevel::LDEBUG:
				return(std::string("DEBUG"));
				break;
			case LogLevel::LINFO:
				return(std::string("INFO"));
				break;
			case LogLevel::LWARNING:
				return(std::string("WARNING"));
				break;
			case LogLevel::LERROR:
				return(std::string("ERROR"));
				break;
			case LogLevel::LFATAL:
				return(std::string("FATAL"));
				break;
			default:
				return(std::string("NULL"));
				break;
			}
		}

	};

};
